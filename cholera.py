# -*- coding: utf-8 -*-
"""cholera.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14-8qdiqnQAPAJiTrgyV9q9I_VUhHJ1CY
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import warnings
warnings.filterwarnings('ignore')

# Page configuration
st.set_page_config(
    page_title="Cholera Risk Prediction - India",
    page_icon="ü¶†",
    layout="wide",
    initial_sidebar_state="expanded"
)

class CholeraPredictionSystem:
    def __init__(self):
        self.setup_data()

    def setup_data(self):
        """Initialize sample dataset for demonstration"""
        np.random.seed(42)
        n_samples = 2000

        # Indian states with regional distribution
        states = ['Maharashtra', 'Kerala', 'West Bengal', 'Gujarat', 'Karnataka',
                 'Tamil Nadu', 'Uttar Pradesh', 'Bihar', 'Assam', 'Odisha',
                 'Rajasthan', 'Punjab', 'Haryana', 'Madhya Pradesh', 'Andhra Pradesh']

        # Generate realistic sample data
        self.data = pd.DataFrame({
            'state': np.random.choice(states, n_samples),
            'year': np.random.randint(2010, 2024, n_samples),
            'month': np.random.randint(1, 13, n_samples),
            'temperature': np.random.normal(28, 5, n_samples),
            'rainfall': np.random.gamma(2, 2, n_samples),
            'humidity': np.random.normal(65, 15, n_samples),
            'population_density': np.random.uniform(100, 2000, n_samples),
            'sanitation_index': np.random.uniform(0.3, 0.9, n_samples),
        })

        # Generate realistic target variable based on multiple conditions
        risk_conditions = (
            (self.data['temperature'] > 30) &
            (self.data['rainfall'] > 4) &
            (self.data['humidity'] > 70) &
            (self.data['sanitation_index'] < 0.6)
        )

        medium_conditions = (
            (self.data['temperature'] > 25) &
            (self.data['rainfall'] > 2) &
            (self.data['humidity'] > 60)
        )

        self.data['risk_level'] = np.where(
            risk_conditions, 'High',
            np.where(medium_conditions, 'Medium', 'Low')
        )

        # Add case counts based on risk level
        self.data['case_count'] = np.where(
            self.data['risk_level'] == 'High',
            np.random.poisson(150, n_samples),
            np.where(
                self.data['risk_level'] == 'Medium',
                np.random.poisson(75, n_samples),
                np.random.poisson(25, n_samples)
            )
        )

        # Prepare features for ML
        self.features = ['temperature', 'rainfall', 'humidity', 'population_density', 'sanitation_index']

        # Encode categorical variables
        self.le_state = LabelEncoder()
        self.le_risk = LabelEncoder()

        self.data['state_encoded'] = self.le_state.fit_transform(self.data['state'])
        self.data['risk_encoded'] = self.le_risk.fit_transform(self.data['risk_level'])

        self.X = self.data[self.features]
        self.y = self.data['risk_encoded']

        # Scale features
        self.scaler = StandardScaler()
        self.X_scaled = self.scaler.fit_transform(self.X)

        # Initialize models
        self.models = {
            'Random Forest': RandomForestClassifier(n_estimators=100, random_state=42),
            'SVM': SVC(kernel='rbf', probability=True, random_state=42),
            'Logistic Regression': LogisticRegression(random_state=42),
            'Decision Tree': DecisionTreeClassifier(random_state=42),
            'Naive Bayes': GaussianNB()
        }

        self.trained_models = {}
        self.model_performance = {}

    def train_models(self):
        """Train all machine learning models"""
        # Split data
        X_train, X_test, y_train, y_test = train_test_split(
            self.X_scaled, self.y, test_size=0.2, random_state=42, stratify=self.y
        )

        # Train models
        self.model_performance = {}

        for name, model in self.models.items():
            model.fit(X_train, y_train)
            self.trained_models[name] = model

            # Calculate performance
            y_pred = model.predict(X_test)
            accuracy = accuracy_score(y_test, y_pred)

            self.model_performance[name] = {
                'accuracy': accuracy,
                'predictions': y_pred,
                'actual': y_test,
                'model': model
            }

    def predict_risk(self, input_data, model_name):
        """Predict cholera risk for given input"""
        if model_name not in self.trained_models:
            return None, None

        model = self.trained_models[model_name]
        input_scaled = self.scaler.transform([input_data])

        prediction_encoded = model.predict(input_scaled)[0]
        probability = model.predict_proba(input_scaled)[0]

        prediction = self.le_risk.inverse_transform([prediction_encoded])[0]

        return prediction, probability

# Initialize the system
@st.cache_resource
def load_system():
    return CholeraPredictionSystem()

system = load_system()

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #2c3e50;
        text-align: center;
        margin-bottom: 2rem;
    }
    .risk-low {
        background-color: #d4edda;
        color: #155724;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        font-weight: bold;
    }
    .risk-medium {
        background-color: #fff3cd;
        color: #856404;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        font-weight: bold;
    }
    .risk-high {
        background-color: #f8d7da;
        color: #721c24;
        padding: 10px;
        border-radius: 5px;
        text-align: center;
        font-weight: bold;
    }
    .metric-card {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 10px;
        border-left: 4px solid #3498db;
    }
</style>
""", unsafe_allow_html=True)

# Sidebar
st.sidebar.title("ü¶† Cholera Prediction System")
st.sidebar.markdown("---")

# Main title
st.markdown('<h1 class="main-header">Cholera Risk Prediction Dashboard - India</h1>', unsafe_allow_html=True)

# Tabs
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "üè† Dashboard",
    "üîç Prediction",
    "üìä Analytics",
    "üó∫Ô∏è State Analysis",
    "üìà Model Performance"
])

with tab1:
    st.header("Overview Dashboard")

    # Key Metrics
    col1, col2, col3, col4 = st.columns(4)

    with col1:
        total_records = len(system.data)
        st.metric("Total Records", f"{total_records:,}")

    with col2:
        high_risk_pct = (system.data['risk_level'] == 'High').mean() * 100
        st.metric("High Risk Cases", f"{high_risk_pct:.1f}%")

    with col3:
        avg_cases = system.data['case_count'].mean()
        st.metric("Average Cases", f"{avg_cases:.0f}")

    with col4:
        states_covered = system.data['state'].nunique()
        st.metric("States Covered", states_covered)

    st.markdown("---")

    # Charts
    col1, col2 = st.columns(2)

    with col1:
        # Risk Level Distribution
        risk_counts = system.data['risk_level'].value_counts()
        fig_risk = px.pie(
            values=risk_counts.values,
            names=risk_counts.index,
            title="Risk Level Distribution",
            color=risk_counts.index,
            color_discrete_map={'Low': '#90EE90', 'Medium': '#FFD700', 'High': '#FF6B6B'}
        )
        st.plotly_chart(fig_risk, use_container_width=True)

    with col2:
        # Monthly Cases Trend
        monthly_cases = system.data.groupby('month')['case_count'].mean().reset_index()
        fig_trend = px.line(
            monthly_cases,
            x='month',
            y='case_count',
            title="Average Monthly Case Distribution",
            labels={'case_count': 'Average Cases', 'month': 'Month'}
        )
        st.plotly_chart(fig_trend, use_container_width=True)

    # State-wise Analysis
    st.subheader("State-wise Risk Analysis")
    state_risk = system.data.groupby('state').agg({
        'risk_level': lambda x: (x == 'High').mean(),
        'case_count': 'mean'
    }).reset_index()

    col1, col2 = st.columns(2)

    with col1:
        fig_state_risk = px.bar(
            state_risk.nlargest(10, 'risk_level'),
            x='state',
            y='risk_level',
            title="Top 10 States by High Risk Probability",
            labels={'risk_level': 'High Risk Probability', 'state': 'State'}
        )
        st.plotly_chart(fig_state_risk, use_container_width=True)

    with col2:
        fig_state_cases = px.bar(
            state_risk.nlargest(10, 'case_count'),
            x='state',
            y='case_count',
            title="Top 10 States by Average Cases",
            labels={'case_count': 'Average Cases', 'state': 'State'}
        )
        st.plotly_chart(fig_state_cases, use_container_width=True)

with tab2:
    st.header("Real-time Risk Prediction")

    col1, col2 = st.columns([2, 1])

    with col1:
        # Input parameters
        st.subheader("Environmental Parameters")

        input_col1, input_col2 = st.columns(2)

        with input_col1:
            state = st.selectbox("Select State", system.le_state.classes_)
            temperature = st.slider("Temperature (¬∞C)", 15.0, 45.0, 28.0, 0.1)
            rainfall = st.slider("Rainfall (mm)", 0.0, 10.0, 2.0, 0.1)

        with input_col2:
            humidity = st.slider("Humidity (%)", 30.0, 100.0, 65.0, 0.1)
            population_density = st.slider("Population Density (per sq km)", 100, 2000, 500)
            sanitation_index = st.slider("Sanitation Index", 0.3, 0.9, 0.6, 0.01)

        model_selection = st.selectbox("Select ML Model", list(system.models.keys()))

        # Train models button
        if st.button("üöÄ Train Models & Predict", type="primary"):
            with st.spinner("Training models and making prediction..."):
                system.train_models()

                input_data = [temperature, rainfall, humidity, population_density, sanitation_index]
                prediction, probability = system.predict_risk(input_data, model_selection)

                if prediction:
                    st.session_state.prediction = prediction
                    st.session_state.probability = probability
                    st.session_state.model_used = model_selection
                    st.session_state.input_data = input_data

    with col2:
        st.subheader("Prediction Results")

        if 'prediction' in st.session_state:
            prediction = st.session_state.prediction
            probability = st.session_state.probability

            # Display risk level with appropriate styling
            risk_classes = {
                'Low': 'risk-low',
                'Medium': 'risk-medium',
                'High': 'risk-high'
            }

            st.markdown(f'<div class="{risk_classes[prediction]}">Predicted Risk: {prediction}</div>',
                       unsafe_allow_html=True)

            # Probability distribution
            st.subheader("Probability Distribution")
            prob_df = pd.DataFrame({
                'Risk Level': ['Low', 'Medium', 'High'],
                'Probability': probability
            })

            fig_prob = px.bar(
                prob_df,
                x='Risk Level',
                y='Probability',
                color='Risk Level',
                color_discrete_map={'Low': '#90EE90', 'Medium': '#FFD700', 'High': '#FF6B6B'}
            )
            fig_prob.update_layout(yaxis_tickformat='.0%')
            st.plotly_chart(fig_prob, use_container_width=True)

            # Key factors
            st.subheader("Key Risk Factors")
            risk_factors = []
            if temperature > 30:
                risk_factors.append("High Temperature")
            if rainfall > 4:
                risk_factors.append("Heavy Rainfall")
            if humidity > 70:
                risk_factors.append("High Humidity")
            if sanitation_index < 0.6:
                risk_factors.append("Poor Sanitation")

            if risk_factors:
                for factor in risk_factors:
                    st.write(f"‚Ä¢ {factor}")
            else:
                st.write("‚Ä¢ Favorable conditions")
        else:
            st.info("Please train models and make a prediction to see results here.")

with tab3:
    st.header("Data Analytics & Insights")

    # Correlation Analysis
    st.subheader("Feature Correlation Analysis")

    # Select features for correlation
    selected_features = st.multiselect(
        "Select features for correlation analysis",
        system.features + ['case_count'],
        default=system.features[:3] + ['case_count']
    )

    if selected_features:
        corr_data = system.data[selected_features + ['risk_encoded']]
        correlation_matrix = corr_data.corr()

        fig_corr = px.imshow(
            correlation_matrix,
            title="Feature Correlation Matrix",
            aspect="auto",
            color_continuous_scale="RdBu_r"
        )
        st.plotly_chart(fig_corr, use_container_width=True)

    # Feature distributions
    st.subheader("Feature Distributions by Risk Level")

    feature_to_plot = st.selectbox("Select feature to visualize", system.features)

    fig_dist = px.box(
        system.data,
        x='risk_level',
        y=feature_to_plot,
        color='risk_level',
        title=f"{feature_to_plot} Distribution by Risk Level",
        color_discrete_map={'Low': '#90EE90', 'Medium': '#FFD700', 'High': '#FF6B6B'}
    )
    st.plotly_chart(fig_dist, use_container_width=True)

    # Time series analysis
    st.subheader("Temporal Analysis")

    year_range = st.slider("Select Year Range",
                          min_value=int(system.data['year'].min()),
                          max_value=int(system.data['year'].max()),
                          value=(2015, 2023))

    filtered_data = system.data[
        (system.data['year'] >= year_range[0]) &
        (system.data['year'] <= year_range[1])
    ]

    yearly_trend = filtered_data.groupby('year').agg({
        'case_count': 'mean',
        'risk_level': lambda x: (x == 'High').mean()
    }).reset_index()

    fig_trend = make_subplots(specs=[[{"secondary_y": True}]])

    fig_trend.add_trace(
        go.Scatter(x=yearly_trend['year'], y=yearly_trend['case_count'],
                  name="Average Cases", line=dict(color='blue')),
        secondary_y=False,
    )

    fig_trend.add_trace(
        go.Scatter(x=yearly_trend['year'], y=yearly_trend['risk_level'],
                  name="High Risk Probability", line=dict(color='red')),
        secondary_y=True,
    )

    fig_trend.update_layout(title="Yearly Trends: Cases vs High Risk Probability")
    fig_trend.update_xaxes(title_text="Year")
    fig_trend.update_yaxes(title_text="Average Cases", secondary_y=False)
    fig_trend.update_yaxes(title_text="High Risk Probability", secondary_y=True)

    st.plotly_chart(fig_trend, use_container_width=True)

with tab4:
    st.header("State-wise Detailed Analysis")

    selected_state = st.selectbox("Select State for Detailed Analysis", system.le_state.classes_)

    state_data = system.data[system.data['state'] == selected_state]

    if not state_data.empty:
        col1, col2 = st.columns(2)

        with col1:
            # State summary metrics
            st.subheader(f"{selected_state} - Summary")

            avg_cases = state_data['case_count'].mean()
            high_risk_pct = (state_data['risk_level'] == 'High').mean() * 100
            avg_temp = state_data['temperature'].mean()
            avg_rainfall = state_data['rainfall'].mean()

            st.metric("Average Cases", f"{avg_cases:.0f}")
            st.metric("High Risk Probability", f"{high_risk_pct:.1f}%")
            st.metric("Average Temperature", f"{avg_temp:.1f}¬∞C")
            st.metric("Average Rainfall", f"{avg_rainfall:.1f}mm")

        with col2:
            # Risk distribution for selected state
            state_risk_dist = state_data['risk_level'].value_counts()
            fig_state_pie = px.pie(
                values=state_risk_dist.values,
                names=state_risk_dist.index,
                title=f"Risk Distribution - {selected_state}",
                color=state_risk_dist.index,
                color_discrete_map={'Low': '#90EE90', 'Medium': '#FFD700', 'High': '#FF6B6B'}
            )
            st.plotly_chart(fig_state_pie, use_container_width=True)

        # Monthly patterns for selected state
        st.subheader("Monthly Patterns")
        monthly_state = state_data.groupby('month').agg({
            'case_count': 'mean',
            'temperature': 'mean',
            'rainfall': 'mean'
        }).reset_index()

        fig_monthly = make_subplots(specs=[[{"secondary_y": True}]])

        fig_monthly.add_trace(
            go.Scatter(x=monthly_state['month'], y=monthly_state['case_count'],
                      name="Cases", line=dict(color='red')),
            secondary_y=False,
        )

        fig_monthly.add_trace(
            go.Scatter(x=monthly_state['month'], y=monthly_state['temperature'],
                      name="Temperature", line=dict(color='orange')),
            secondary_y=True,
        )

        fig_monthly.add_trace(
            go.Bar(x=monthly_state['month'], y=monthly_state['rainfall'],
                   name="Rainfall", opacity=0.3),
            secondary_y=True,
        )

        fig_monthly.update_layout(title=f"Monthly Patterns - {selected_state}")
        fig_monthly.update_xaxes(title_text="Month")
        fig_monthly.update_yaxes(title_text="Average Cases", secondary_y=False)
        fig_monthly.update_yaxes(title_text="Temperature/Rainfall", secondary_y=True)

        st.plotly_chart(fig_monthly, use_container_width=True)

with tab5:
    st.header("Model Performance Analysis")

    if not system.model_performance:
        st.warning("Please train models first from the Prediction tab to see performance metrics.")
    else:
        # Model comparison
        st.subheader("Model Accuracy Comparison")

        model_names = list(system.model_performance.keys())
        accuracies = [system.model_performance[name]['accuracy'] for name in model_names]

        perf_df = pd.DataFrame({
            'Model': model_names,
            'Accuracy': accuracies
        })

        col1, col2 = st.columns(2)

        with col1:
            fig_accuracy = px.bar(
                perf_df,
                x='Model',
                y='Accuracy',
                title="Model Accuracy Comparison",
                color='Accuracy',
                color_continuous_scale='Viridis'
            )
            fig_accuracy.update_layout(yaxis_tickformat='.0%')
            st.plotly_chart(fig_accuracy, use_container_width=True)

        with col2:
            # Best model info
            best_model = perf_df.loc[perf_df['Accuracy'].idxmax()]
            st.metric("Best Performing Model", best_model['Model'])
            st.metric("Best Accuracy", f"{best_model['Accuracy']:.1%}")

            # Model recommendations
            st.subheader("Model Recommendations")
            st.write("""
            - **Random Forest**: Best for overall accuracy and feature importance
            - **SVM**: Good for complex decision boundaries
            - **Logistic Regression**: Fast and interpretable
            - **Decision Tree**: Easy to interpret but may overfit
            - **Naive Bayes**: Fast and works well with independent features
            """)

        # Confusion Matrix for best model
        st.subheader(f"Confusion Matrix - {best_model['Model']}")

        best_model_data = system.model_performance[best_model['Model']]
        cm = confusion_matrix(best_model_data['actual'], best_model_data['predictions'])

        fig_cm = px.imshow(
            cm,
            text_auto=True,
            title=f"Confusion Matrix - {best_model['Model']}",
            labels=dict(x="Predicted", y="Actual", color="Count"),
            x=['Low', 'Medium', 'High'],
            y=['Low', 'Medium', 'High'],
            color_continuous_scale='Blues'
        )
        st.plotly_chart(fig_cm, use_container_width=True)

        # Feature importance for tree-based models
        if best_model['Model'] in ['Random Forest', 'Decision Tree']:
            st.subheader("Feature Importance")
            model = best_model_data['model']

            if hasattr(model, 'feature_importances_'):
                importance_df = pd.DataFrame({
                    'Feature': system.features,
                    'Importance': model.feature_importances_
                }).sort_values('Importance', ascending=True)

                fig_importance = px.bar(
                    importance_df,
                    x='Importance',
                    y='Feature',
                    orientation='h',
                    title="Feature Importance",
                    color='Importance',
                    color_continuous_scale='Viridis'
                )
                st.plotly_chart(fig_importance, use_container_width=True)

# Footer
st.markdown("---")
st.markdown(
    """
    <div style='text-align: center; color: gray;'>
        <p>Cholera Risk Prediction System - India | Developed for Public Health Monitoring</p>
        <p>Uses Machine Learning for proactive cholera outbreak prediction</p>
    </div>
    """,
    unsafe_allow_html=True
)

